#!/bin/bash
# Purpose:     This script attempts to generate random integers through any means necessary
# Author:      Rawiri Blundell
# Copyright:   (c) 2016 - Beerware As-Is.  
#              No warranty or liability, but some attribution would be nice if it works well
#              for you or you derive your own code.  Just as I've attributed inspiration below.
# Date:        20160222
# Interpreter: This may have a bash shebang, but should work fine in any POSIX compatible shell
#              #!/usr/bin/env ksh or #!/bin/ksh will probably get you working on almost anything
###############################################################################
# Inspiration taken from:
# Colin Riddel provided the perl one liner that started this
# 'rand' by Heiner Steven:
# http://www.shelldorado.com/scripts/cmds/rand
# 'rand' by Malte Skoruppa:
# http://unix.stackexchange.com/questions/157250/how-to-efficiently-generate-large-uniformly-distributed-random-integers-in-bas
# 'randbits' by Gene Spafford:
# http://www.diablotin.com/librairie/networking/puis/ch23_09.htm
###############################################################################
# Set the default variable states
nMin=1
#nMax=32767
#nMax=4294967295           #2^32-1
#nMax=72057594037927935    #2^56-1
nMax=9223372036854775807   #2^63-1
debug=false
nCount=1
repeat=false
zeroPad=false
tmpDir=/tmp/rand

# In case we actually use $tmpDir, let's trap and delete it
trap 'rm -rf "${tmpDir}"' EXIT INT TERM HUP

# Getopts
while getopts "dhm:M:N:rz" Flags; do
  case "${Flags}" in
    d)  debug="true";;
    h)  printf "%s\n" "" "rand - generate random positive integers" \
        "" "Optional Arguments:" \
        "-d [debug.  Tells you which processing method is used (Default:off)]" \
        "-h [help]" \
        "-m [minimum number (Default:${nMin})]" \
        "-M [maximum number (Default:${nMax})]" \
        "-N [count.  Number of numbers (Default:${nCount})]" \
        "-r [repeat.  Output lines may be repeated (Default:off)]" \
        "-z [zero pad single digits.  E.g. '9' becomes '09' (Default:off)]" ""
        exit 0;;
    m)  case "${OPTARG}" in
          *[!0-9]*|'') printf "%s\n" "[ERROR] rand: (-m) '${OPTARG}' is not a number"; exit 1;;
          *)           nMin="${OPTARG}";;
        esac;;
    M)  case "${OPTARG}" in
          *[!0-9]*|'') printf "%s\n" "[ERROR] rand: (-M) '${OPTARG}' is not a number"; exit 1;;
          *)           nMax="${OPTARG}";;
        esac;;
    N)  case "${OPTARG}" in
          *[!0-9]*|'') printf "%s\n" "[ERROR] rand: (-N) '${OPTARG}' is not a number"; exit 1;;
          *)           nCount="${OPTARG}";;
        esac;;
    r)  repeat=true;;
    z)  zeroPad=true;;
    \?)  echo "[ERROR] rand: Invalid option: '-$OPTARG'.  Try 'rand -h' for usage."
         exit 1;;
    :)  echo "[INFO] rand: Option '-$OPTARG' requires an argument. e.g. '-$OPTARG 10'"
        exit 1;;
  esac
done

# Double check that we haven't done something silly like have nMax less than nMin
if [ "${nMin}" -ge "${nMax}" ]; then
  printf "%s\n" "[ERROR] rand: (-m) minimum value is greater than or equal to (-M) maximum value" 1>&2
  exit 1
fi

# Put these vars into the environment so we can import them to perl etc
export nMin nMax nCount

################################################################################
# Functions
################################################################################
# Function to determine required bitlength
Fn_bitlen() {
  logn=1
  nBitlen=0
  while [ $((nMax - nMin)) -gt "${logn}" ] && [ "${logn}" -gt 0 ]; do
    logn=$(( logn * 2 ))
    nBitlen=$(( nBitlen + 1 ))
  done
}

# Function to quickly rotate ASCII characters by 90 places
# emulates Fn_xor in a lazy way but is infinitely faster
Fn_chrotate() {
  # shellcheck disable=SC2020
  tr ' !"#$%&()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~' 'z{|}~ !"#$%&()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxy'
}

# This function ensures equal distribution for methods that don't support it
# If you request random numbers between 1 and 10, you should only get a complete
# set of random numbers between 1 and 10.  This is disabled with '-r'
# Note: for POSIX compat, we sadly can't use arrays (can we test for that capability?)
# this means there will be potentially a massive performance hit at scale
Fn_fill() {
  # Capture the requested number of integers
  maxCount="${nCount}"
  
  # Multiply the original count to improve the chances of unique elements being selected
  nCount=$(( nCount * 15 ))
  
  # Call the method specified upon function invocation
  # Use Fn_unique to get an unsorted list of unique integers
  initFill=$($1 | Fn_unique)

  # Count how many unique integers we have generated
  initCount=$(printf "%s\n" "${initFill}" | wc -l)

  # If we've generated enough to satisfy nCount, then we just print them out
  if [ "${initCount}" -ge "${maxCount}" ]; then
    printf "%s\n" "${initFill}" | head -n "${maxCount}"
    
  # Otherwise, we walk through a few steps to try and quickly fill the gap
  else
    # Create a tmpdir
    mkdir -p "${tmpDir}"
    
    # Now let's make these files, starting by dumping what we already have
    printf "%s\n" "${initFill}" > "${tmpDir}"/rnginit

    # Next, let's generate a list of what's missing
    printf "%s\n" "${initFill}" "$(seq "${nMin}" "${nMax}")" | sort | uniq -u > "${tmpDir}"/rngdiff
      
    # Interleave the two using 'paste' and dump them out
    paste -d '\n' "${tmpDir}"/rnginit "${tmpDir}"/rngdiff | grep . | head -n "${maxCount}"
  fi
}

# This function allows us to print out unsorted, unique integers
Fn_unique() {
  # If 'awk' is available, we use it
  if command -v awk >/dev/null 2>&1; then
    awk '!x[$0]++'
  # Otherwise we use a double sort.  This can be brutally slow at scale.
  # We first prepend each line with a line number, then perform a unique short-name
  # on the second field (i.e. the generated integers), then we sort again on the
  # line numbers to return the randomness and use cut to print out the integers
  else
    nl | sort -k 2 -u | sort | cut -f2
  fi
}

# xor function derived from http://zurlinux.com/?p=712
Fn_xor() {
  while read -r line; do
    # Start by removing whitespace to reduce character bias
    # pipe to 'od' which converts each character to one octal per line
    for i in $(printf "%s" "${line}" | tr -d " " | od -A n -t o1 -w1 -v); do
      # for each octal, run an xor and then print it
      # shellcheck disable=SC2059
      printf \\"$(printf '%03o' "$(( i ^ 90 ))" )"
    done
  done
}

# Setup the zeropad function
if [ "${zeroPad}" = true ]; then
  Fn_zeropad() {
    # It appears that 'awk' is more portable vs sed 's/\<[0-9]\>/0&/'
    if command -v awk >/dev/null 2>&1; then
      awk '{$1 = sprintf("%02d", $1); print}'
    else
      printf "%s\n" "[ERROR] rand: 'awk' is required for zero-padding but was not found."
      exit 1
    fi
  }
else
  Fn_zeropad() { 
    cat -
  }
fi

# Function to generate numbers using 'gawk'
method_gawk() {
  gawk -v min="${nMin}" -v max="${nMax}" -v nNum="${nCount}" 'BEGIN{srand(systime() + PROCINFO["pid"]); i = 0; while (i < nNum) { print int(min+rand()*(max-min)); ++i} }'
}

# Function to generate numbers using BSD 'jot'
method_jot() {
  jot -w %i -r "${nCount}" "${nMin}" "${nMax}"
}

# Function to generate numbers using manual entropy generation
method_manual() {
  # Check we have the required binaries
  ErrCount=0
  for Prog in od tr tail head; do
    if ! command -v "${Prog}" >/dev/null 2>&1; then
      printf "%s\n" "[ERROR] rand: '${Prog}' is required but was not found."
      ErrCount=$(( ErrCount + 1 ))
    fi
  done

  # If any packages are missing, then ErrCount's going
  # to be greater than 0, in which case, exit.
  if [ "${ErrCount}" -gt 0 ]; then
    exit 1
  fi

  # Let's try and find a hashing method, we use this sparingly for now
  for cryptopt in sha256sum sha1sum shasum md5sum digest csum cksum; do
    if command -v "${cryptopt}" > /dev/null 2>&1; then
      crypt="${cryptopt}"
      if [ "${crypt}" = digest ]; then
        crypt="digest -v -a md5"
      fi
      break
    else
      printf "%s\n" "[ERROR] rand: 'manual entropy' method was selected, but no hash method is available."
      exit 1
    fi
  done

  # We need some "entropy", so let's first check for an existing entropy file from
  # a previous invocation.  If found, we want to rotate its characters
  if [ -f /tmp/entropy ]; then
    Fn_chrotate < /tmp/entropy > /tmp/entropy2
    mv /tmp/entropy2 /tmp/entropy

  # Otherwise, let's generate some "entropy" by simply running through this list of commands
  # And trying to remove as much whitespace as possible, then do a fast 'xor'
  # Some of these may fail, so we redirect stderr into the stream anyway.  Throw it all at the wall, see what sticks.
  else
    {
      vmstat -s
      vmstat -c
      pfstat
      vmstat -i
      netstat -s
      nfsstat
      netstat -m
      netstat -in
      mpstat
      w
      df
      portstat
      iostat
      uptime
      vmstat -f
      vmstat
      netstat -n
      lsof
      ps aux
      ipcs -a
      pstat -afipSsT
      pstat -p
      pstat -S
      pstat -v
      pstat -x
      pstat -t
      last -n 50
      arp -a
      ripquery -nw 1 127.0.0.1
      lpstat -t
      tcpdump -c 5 -efvvx
    } 2>&1 | tr -d " " | tr -d "\n" | Fn_chrotate > /tmp/entropy
  fi

  while [ "${nCount}" -gt 0 ]; do

    # Get a string of 4 bytes from /tmp/entropy using od
    # format it as an unsigned integer between 0 and 2^32-1
    nRand=$(od -N 4 -A n -t uL /tmp/entropy | tr -d " ")

    # Pass nRand through a standard modulo
    printf "%s\n" "$(( nRand % (nMax + 1 - nMin) + nMin ))"

    # Decrement the counter
    nCount=$(( nCount - 1 ))

    # Now we have to churn the entropy file.  We remove the leading 32 Bytes 
    # of the entropy file, and temporarily store the result
    tail -c +33 /tmp/entropy | tr -d "\n" > /tmp/entropy2

    {
      # Seed some more data into the temporary entropy file, here we hash the PID
      printf "%s" "$$" | Fn_xor | tr -d " " | tr -d "\n" | "${crypt}"
      # Rotate the entropy, get the first 64 chars, xor it to the bottom of the temp file
      printf "%s" "$(fold -b -w 64 /tmp/entropy | head -1 | Fn_xor)"
      date '+%H%M%S' | Fn_xor | tr -d " " | tr -d "\n"
    } >> /tmp/entropy2

    # Move the temporary file into place
    mv /tmp/entropy2 /tmp/entropy
  done 
}

# Function to generate numbers using 'nawk'
method_nawk() {
  nawk -v min="${nMin}" -v max="${nMax}" -v nNum="${nCount}" -v seed="$(date +%Y%M%d%H%M%S)" 'BEGIN {srand(seed); i = 0; while (i < nNum) { print int(min+rand()*(max-min)); ++i} }'
}

# Function to generate numbers using 'perl'
method_perl() {
  perl -le '$mn=$ENV{nMin}; $mx=$ENV{nMax}; $cn=$ENV{nCount}; foreach my $i (1..$cn) { printf "%.0f\n", int(rand($mx-$mn))+$mn ; }'
}

# Function to generate numbers using 'python'
method_python() {
  python -c "for _ in xrange(${nCount}): import random; print random.randint(${nMin},${nMax})"
}

# Function to generate numbers using shell 'RANDOM' special variable
method_RANDOM() {
  # We need to know the number of bits required to represent nMax (i.e. bitlength)
  Fn_bitlen

  # Start a loop based on nCount.  I thought of other ways, but this works easier
  # and can be made more portable if testing proves the need to do so
  while [ "${nCount}" -gt 0 ]; do
    rndBitlen=15
    rnd=$RANDOM # Capture one output sample of RANDOM
    while [ "${rndBitlen}" -lt "${nBitlen}" ]; do
      # Bitshift RANDOM to the left to stack it i.e. 15 int -> 30 int -> 45 int etc
      rnd=$(( rnd<<15|RANDOM ))
      # Keep stacking until the while loop exits
      rndBitlen=$(( rndBitlen + 15 ))
    done
    # Now bitshift it right
    nRandShift=$(( rnd>>(rndBitlen-nBitlen) ))

    # Next we test if the number we've generated fits into our range.  If so,
    # then we can use it and iterate the while loop
    # We add a test for greater than 0, as we want to print positive integers
    # This has a performance hit, but is for consistency with the other methods used
    if [ $((nRandShift + nMin)) -le "${nMax}" ] && [ $((nRandShift + nMin)) -gt 0 ]; then
      printf "%s\n" "$(( nRandShift + nMin ))"
      nCount=$(( nCount - 1 ))
    fi
  done
}

# Function to generate numbers using GNU 'shuf'
method_shuf() {
  # It turns out that Solaris 11 comes with 'shuf' v8.16, which lacks the 
  # '-r' option.  This option was introduced in v8.22
  # Once again, Solaris proves to be the bane of my scripting existence.  

  # First we test if the repeat option has been set, as this requires special handling
  if [ "${repeat}" = true ]; then
    # Test if 'shuf' can use '-r' and if so, use it
    if shuf -n 1 -r -i 1-10 >/dev/null 2>&1; then
      shuf -n "${nCount}" -r -i "${nMin}"-"${nMax}"

    # Otherwise we assume that '-r' isn't available, and do it the old fashioned way
    else
      while [ "${nCount}" -gt 0 ]; do
        shuf -n 1 -i "${nMin}"-"${nMax}"
        # Decrement the counter
        nCount=$(( nCount - 1 ))
      done
    fi
  # If repeat isn't true, just do this
  else
    shuf -n "${nCount}" -i "${nMin}"-"${nMax}"
  fi
}

# Function to generate random numbers using '/dev/urandom'
method_urandom() {
  # Check we have the required binaries
  ErrCount=0
  for Prog in od tr; do
    if ! command -v "${Prog}" >/dev/null 2>&1; then
      printf "%s\n" "[ERROR] rand: '${Prog}' is required but was not found."
      ErrCount=$(( ErrCount + 1 ))
    fi
  done

  # If any packages are missing, then ErrCount's going
  # to be greater than 0, in which case, exit.
  if [ "${ErrCount}" -gt 0 ]; then
    exit 1
  fi

  # If performance is more important to you than functionality, uncomment this
  # This will have the effect of limiting this mode to 56 bit integers
  # Which makes '&& [ $((nRandShift + nMin)) -gt 0 ]' effectively redundant.
  #if (( nMax > (2**56-1) )); then
  #  nMax=$((2**56-1))
  #fi

  # We need to know the number of bits required to represent nMax (i.e. bitlength)
  Fn_bitlen

  # The lowest number of bytes needed to get at least n bits is the
  # lowest multiple of 8 that is greater than or equal to n
  nBytes=$(( (nBitlen + 7) / 8 ))

  while [ "${nCount}" -gt 0 ]; do

    # Get a string of bytes from /dev/urandom using od
    nRand=$(od -N "${nBytes}" -A n -t uL /dev/urandom | tr -d " ")

    # Now we bitshift to the right
    nRandShift=$(( nRand>>(nBytes * 8 - nBitlen) ))

    if [ $((nRandShift + nMin)) -le "${nMax}" ] && [ $((nRandShift + nMin)) -gt 0 ]; then
      printf "%s\n" "$(( nRandShift + nMin ))"
      nCount=$(( nCount - 1 ))
    fi
  done 
}

# Check if 'seq' is available, if not, provide a basic replacement function
# Note: this has been stripped back to cater only for ascending sequences
# A full, bash-friendly version is available at https://github.com/rawiriblundell
if ! command -v seq >/dev/null 2>&1; then
  seq() {
    i=$1
    while [ "$i" -ne "$(( $2 + 1 ))" ]; do
      printf "%s\n" "$i"
      i=$(( i + 1 ))
    done
  }
fi

###############################################################################
# Main
###############################################################################
# Cater for GNU shuf, nice and fast
# This function will also cater for the repeat option natively
if command -v shuf > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'shuf'"
  fi
  method_shuf

# If we're on a BSD based host, likely 'jot' is available, so let's use it
# 'jot' is theoretically limited to 2^32-1 by the arc4random algorithm
# In testing it seems to  be limited somewhere between 2^31-1 and 2^32-1
# so we set a limit based on the former figure of 2^31-1
elif command -v jot > /dev/null 2>&1 && [ "${nMax}" -lt 2147483647 ]; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'jot'"
  fi
  # Repeating generated numbers is the default behaviour of 'jot'
  if [ "${repeat}" = true ]; then
    method_jot
  else
    Fn_fill method_jot
  fi

# Now we start going less-native and try perl.  Very likely to be there,   
# so very likely this will be a commonly used option
elif command -v perl > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'perl'"
  fi
  if [ "${repeat}" = true ]; then
    method_perl
  else
    Fn_fill method_perl
  fi

# Otherwise, we try python
elif command -v python > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'python'"
  fi
  if [ "${repeat}" = true ]; then
    method_python
  else
    Fn_fill method_python
  fi

# No perl or python?  Let's try 'gawk'
elif command -v gawk > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'gawk'"
  fi
  if [ "${repeat}" = true ]; then
    method_gawk
  else
    Fn_fill method_gawk
  fi
  
# No gawk?  Surely 'nawk' is hanging around?  Works very similar, but because we don't have systime()
# we have to replicate it as a seed for srand().  Possibly less random or slower compared to gawk
# More testing will need to be performed.
elif command -v nawk > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'nawk'"
  fi
  if [ "${repeat}" = true ]; then
    method_nawk
  else
    Fn_fill method_nawk
  fi

# Note: oawk does not have srand() or rand(), it's more trouble than it's worth so let's move on

# No perl, python, gawk or nawk?   We're *really* regressing now.  Let's try for a POSIX friendly shell solution
# We start by checking if we have the RANDOM env var
elif [ -n "${RANDOM}" ]; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'shell builtin RANDOM variable'"
  fi
  if [ "${repeat}" = true ]; then
    method_RANDOM
  else
    Fn_fill method_RANDOM
  fi

# Next, we look for /dev/urandom.  This method can allow for bulk numbers with large ranges, but is slower than RANDOM
elif [ -c /dev/urandom ]; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is '/dev/urandom'"
  fi
  if [ "${repeat}" = true ]; then
    method_urandom
  else
    Fn_fill method_urandom
  fi  

# If there's no shuf, jot, perl, python, gawk, nawk, $RANDOM or /dev/urandom, then what savage OS are we on?
# Let's try to make something up.  Let's be honest, though, by this point it's an academic exercise.
#
# Originally this was based off PID + date, but was rewritten to generate and churn a sufficient
# amount of entropy.  Applying /dev/urandom processing gave a very skewed distribution
# and so I decided to limit the number of bytes read and simply use a modulo formula
# The point being that if we ever got to this point, it's enough to generate something.
elif command -v date > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'manual entropy'"
  fi
  if [ "${repeat}" = true ]; then
    method_manual
  else
    Fn_fill method_manual
  fi

# Ultimate failure
else
  printf "%s\n" "[ERROR] rand: I could not find a valid method with which to process your request."
  exit 1
fi | Fn_zeropad
