#!/bin/bash
# Purpose:    This script attempts to generate random integers through any means necessary
# Author:     Rawiri Blundell
# Copyright:  (c) 2016 - Beerware As-Is.  No warranty or liability.
# Date:       20160222
# Interpreter: This may have a bash shebang, but should work fine in any POSIX compatible shell
#              #!/usr/bin/env ksh will probably get you working on almost anything
###############################################################################
# Inspiration taken from:
# Colin Riddel provided the perl one liner that started this
# 'rand' by Heiner Steven:
# http://www.shelldorado.com/scripts/cmds/rand
# 'rand' by Malte Skoruppa:
# http://unix.stackexchange.com/questions/157250/how-to-efficiently-generate-large-uniformly-distributed-random-integers-in-bas
###############################################################################
# Set the default variable states
nMin=1
#nMax=32767
nMax=9223372036854775807 # Signed 64-bit integer limit
debug=false
count=1

# Getopts
while getopts "c:dhm:M:" Flags; do
  case "${Flags}" in
    c)  case "${OPTARG}" in
          *[!0-9]*|'') printf "%s\n" "[ERROR] rand: (-c) '${OPTARG}' is not a number"; exit 1;;
          *)           count="${OPTARG}";;
        esac;;
    d)  debug="true";;
    h)  printf "%s\n" "rand - generate random positive integers" \
        "Optional Arguments:" \
        "-c [count.  Number of numbers (Default:${count})]" \
        "-d [debug.  Tells you which processing method is used (Default:off)]" \
        "-h [help]" \
        "-m [minimum number (Default:${nMin})]" \
        "-M [maximum number (Default:${nMax})]"
        exit 0;;
    m)  case "${OPTARG}" in
          *[!0-9]*|'') printf "%s\n" "[ERROR] rand: (-m) '${OPTARG}' is not a number"; exit 1;;
          *)           nMin="${OPTARG}";;
        esac;;
    M)  case "${OPTARG}" in
          *[!0-9]*|'') printf "%s\n" "[ERROR] rand: (-M) '${OPTARG}' is not a number"; exit 1;;
          *)           nMax="${OPTARG}";;
        esac;;
    \?)  echo "[ERROR] rand: Invalid option: '-$OPTARG'.  Try 'rand -h' for usage." >&2
         exit 1;;
    :)  echo "[INFO] rand: Option '-$OPTARG' requires an argument. e.g. '-$OPTARG 10'" >&2
        exit 1;;
  esac
done

# Double check that we haven't done something silly like have nMax less than nMin
if [ "${nMin}" -ge "${nMax}" ]; then
  printf "%s\n" "[ERROR] rand: (-m) minimum value is greater than or equal to (-M) maximum value" 1>&2
  exit 1
fi

# Put these vars into the environment so we can import them to perl etc
export nMin nMax count

###############################################################################
# Cater for GNU shuf, nice and fast
if command -v shuf > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'shuf'"
  fi
  shuf -i "${nMin}"-"${nMax}" -n "${count}" -r

# If we're on a BSD based host, likely 'jot' is available, so let's use it
elif command -v jot > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'jot'"
  fi
  jot -w %i -r "${count}" "${nMin}" "${nMax}"

# Now we start going less-native and try perl.  Very likely to be there,   
# so very likely this will be a commonly used option
elif command -v perl > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'perl'"
  fi
  perl -le '$mn=$ENV{nMin}; $mx=$ENV{nMax}; $cn=$ENV{count}; foreach my $i (1..$cn) { print int(rand($mx-$mn))+$mn ; }'
  
# Otherwise, we try python
elif command -v python > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'python'"
  fi
  python -c "for _ in xrange(${count}): import random; print random.randint(${nMin},${nMax})"
  
# No perl or python?  Surely awk/oawk/nawk/gawk is hanging around?
elif command -v awk > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'awk'"
  fi
  awk -v min="${nMin}" -v max="${nMax}" -v nNum="${count}" 'BEGIN{srand(systime() + PROCINFO["pid"]); i = 0; while (i < nNum) { print int(min+rand()*(max-min)); ++i} }'

# No perl, python or awk?   We're *really* regressing now.  Let's try for a POSIX friendly shell solution
# We start by checking for /dev/urandom.  This method can allow for bulk numbers with large ranges.
elif [ -c /dev/urandom ]; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is '/dev/urandom'"
  fi

  for nRand in $(tr -dc 0-9 < /dev/urandom | fold -w 10 | head -"${count}"); do
    # We need to prevent any generated numbers from starting with '0'
    # simply swap it for '4', the bashism way is:
    #nRand=${nRand/0/4}
    # The more portable 'sed' way incurs no performance penalty in a quick test:
    nRand=$(printf "%s\n" "${nRand}" | sed -e 's/^0/4/g')

    # Now we pass it through a modulus formula
    printf "%s\n" "$(( nRand % (nMax - nMin) + nMin ))"
  done
  
# Next, check if we have the RANDOM env var
elif [ -n "${RANDOM}" ]; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'shell builtin RANDOM variable'"
  fi

  # amp up RANDOM to a 30-bit integer, then pass it the rest of the formula
  while (( count > 0 )); do
    printf "%s\n" "$(( ((RANDOM<<15)|RANDOM) % (nMax - nMin) + nMin ))"
    (( count = count - 1 ))
  done

# If there's no shuf, jot, perl, python, awk, $RANDOM or /dev/urandom, then what savage OS are we on?
# Let's try to make something using the date command
elif command -v date > /dev/null 2>&1; then
  if [ "${debug}" = true ]; then
    printf "%s\n" "[DEBUG] rand: Method used is 'date'"
  fi

  # Make up a random number based on date and PID.  This is our random seed.
  # Note: this is POSIX compliant 'date', if portability isn't a concern,
  # you could use the GNUistic $(date '+%s%N') and maybe md5sum it for extra randomisation
  nRand=$(printf "%s\n" "$$ + $(date '+%H + %M + %S')" | bc)
  
  while [ $(( count -= 1 )) -ge 0 ]; do
    # Feed our random seed through the modulus formula and capture it to a var
    outRand=$(( nRand % (nMax - nMin) + nMin ))

    # Print it out
    printf "%s\n" "${outRand}"

    # Adjust nRand by adding the last random number 
    # we use fold to limit nRand's length - just in case.
    nRand=$(printf "%s\n" "$(( nRand + outRand ))" | fold -w 10)
  done

# Ultimate failure
else
  printf "%s\n" "[ERROR] rand: I could not find a valid method with which to process your request."
  exit 1
fi
