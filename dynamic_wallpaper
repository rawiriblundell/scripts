#!/bin/bash

# TODO: Attempt to auto-detect and prompt user to confirm?
# Get your location code from https://weather.codes/search
location_code=NZXX0049

# Maximum age for a config file, in seconds
config_max_age=604800 # 604800 = 1 week

################################################################################
# Traps and die()
################################################################################
# Catch our own PID to ensure that die() works within subshells
_self_pid="${$}"
export _self_pid

# Print errors to stderr and then exit
die() {  
  if [ -t 0 ]; then
    printf -- '\e[31m\n[!] %s\e[0m\n\n' "${*}" >&2
  else
    printf -- '\n[!] %s\n\n' "${*}" >&2
  fi
  # Send a TERM signal to the top level PID, this is trapped and exit 1 is forced
  kill -s TERM "${_self_pid}"
}

exit_on_SIGINT() { die Program Interrupted; }
exit_on_SIGTERM() { die Program Terminated; }

trap exit_on_SIGINT SIGINT
trap exit_on_SIGTERM SIGTERM

################################################################################
# Init: ensure required vars and directories are in place
################################################################################
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"

[[ ! -d "${XDG_DATA_HOME}" ]] && die "${XDG_DATA_HOME} not found"
[[ ! -d "${XDG_STATE_HOME}" ]] && die "${XDG_STATE_HOME} not found"

data_dir="${XDG_DATA_HOME}/dynamic_wallpapers"
state_dir="${XDG_STATE_HOME}/dynamic_wallpapers"

mkdir -p "${data_dir}" || die "Could not create ${data_dir}"
mkdir -p "${state_dir}" || die "Could not create ${state_dir}"

################################################################################

get_sunrise_sunset() {
  curl -s "https://weather.com/weather/today/l/${1:?No location code}" | 
    grep SunriseSunset | 
    grep -oE '((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))'
}

seconds_since_midnight() {
  date -d "1970-01-01 UTC ${1:-$(date +%T)}" +%s
}

read_config() {
  if [[ -r "${1:?No config defined}" ]]; then
    . "${1}"
  fi
}

# If there's only two images in our set,
# we treat the first as daytime, and the second as nighttime
#
# If there's more than one image in the set, we work on the following logic:
# Between sunset and sunrise, we use the last image in the set
# We sequence the rest in reverse order and then in-order
# For example, with an 8 image set:
# Overnight: 8
# Daytime: 7, 6, 5, 4, 3, 2, 1, 2, 3, 4, 5, 6, 7
generate_config() {
  [[ -d "${data_dir}/${set_name}" ]] || die "${data_dir}/${set_name} not found."

  # Load our images into an array
  image_set=( "${data_dir}/${set_name}/"* )

  # A one-image set is not what this script is about
  (( "${#image_set[@]}" <= 1 )) && die "${set_name} set size too small (<=1)"

  # Gather our time boundaries
  mapfile -t sunbounds < <(get_sunrise_sunset "${location_code}")
  bound_start="$(seconds_since_midnight "${sunbounds[0]}")"
  bound_end="$(seconds_since_midnight "${sunbounds[1]}")"
  bound_size="$(( bound_end - bound_start ))"
  duration="$(( bound_size / "${#image_set[@]}" ))"

  # The config file is in 'start:finish:filename' format
  # We handle 2-image sets specifically to demonstrate the config structure
  if (( "${#image_set[@]}" == 2 )); then
    {
      # Midnight to sunrise, we use the overnight image
      printf -- '%s:%s:%s\n' "0" "${bound_start}" "${image_set[1]}"
      # Sunrise to sunset, we use the daytime image
      printf -- '%s:%s:%s\n' "${bound_start}" "${bound_end}" "${image_set[0]}"
      # Sunset to midnight, we use the overnight image
      printf -- '%s:%s:%s\n' "${bound_end}" "86400" "${image_set[1]}"
    } > "${state_dir}/${set_name}.conf"
  else
    # Assign the last image in the array to a variable, then remove it from the array
    overnight_image="${image_set[${#image_set[@]}-1]}"
    unset image_set[${#image_set[@]}-1]

    # Build a sequence of images, working from night to day and back to night
    for (( i="${#image_set[@]}";i>=0;--i )); do
      (( i == "${#image_set[@]}" )) && continue
      set_sequence+=( "${image_set[i]}" )
    done
    for (( i=1;i<="${#image_set[@]}";++i )); do
      (( i == "${#image_set[@]}" )) && continue
      set_sequence+=( "${image_set[i]}" )
    done

    # Figure out the duration that each image should run for
    duration=$(( bound_size / ("${#set_sequence[@]}" + 2) ))

    {
      # Midnight to sunrise, we use the overnight image
      printf -- '%s:%s:%s\n' "0" "${bound_start}" "${overnight_image}"

      start="${bound_start}"
      finish="$(( bound_start + duration ))"

      for image in "${set_sequence[@]}"; do
        printf -- '%s:%s:%s\n' "${start}" "${finish}" "${image}"
        start="${finish}"
        finish="$(( finish + duration ))"
      done
      
      # Sunset to midnight, we use the overnight image
      printf -- '%s:%s:%s\n' "${bound_end}" "86400" "${overnight_image}"
    } > "${state_dir}/${set_name}.conf"
  fi
}

read_state() {
  if [[ -r "${state_dir}/current_state" ]]; then
    . "${state_dir}/current_state"
  fi
}

set_state() {
  {
    printf -- '%s\n' "state_file_generated=$(date +%s)" \
      "current_wallpaper=${current_wallpaper}" \
      "current_set_name=${set_name}" \
      "current_set_path=${set_path}"
  } > "${state_dir}/current_state"
}

usage() {
  printf -- '%s\n' "Usage: dynamic_wallpapers setname"
  exit "${1:-0}"
}

################################################################################

current_secs=$(seconds_since_midnight)

get_state

# Define the set_path variable
set_path="${data_dir}/${set_name}"

# Define the set_config variable
set_config="${state_dir}/${set_name}.conf"

# Does the image set have a config in the state_dir?
# We keep disposable configs in files within state_dir rather than a config_dir,
# and rather than generating every run, in order to keep sun-up and sun-down
# aligned and to reduce traffic to/from weather.com
if [[ -f "${set_config}" ]]; then
  # Load it up so that we get $state_file_generated
  . "${set_config}"
  # If it's too old, regenerate and reload it
  if (( $(date +%s) > (state_file_generated + config_max_age) )); then
    generate_config "${set_name}"
    . "${set_config}"
  fi
# If, on the other hand, it doesn't exist, generate and load it
else
  generate_config "${set_name}"
  . "${set_config}"
fi

# By this point, the config should be sorted, so let's work through it
while IFS=: read -r start finish wallpaper; do
  if (( current_secs >= start )) && (( current_secs <= finish )); then
    set_wallpaper "${wallpaper}"
    break
  fi
done < "${set_config}"

case "${1}" in
  (-h|--help|help|--usage|usage)
    usage 0
  ;;
  (''|random)
    # Create an array of set directories from within data_dir
    set_list=( $(find "${data_dir}" -maxdepth 1 -type d | grep -xv "${data_dir}") )
    (( "${#set_list[@]}" == 0 )) && die "No image sets found in ${data_dir}"
    # Randomly select a set from the array
    set_name="${set_list[$RANDOM % ${#set_list[@]}]}"
    printf -- '%s\n' "Randomly selected ${data_dir}/${set_name}..."
  ;;
  (*)
    if [[ -d "${data_dir}/${1}" ]]; then
      set_name="${1}"
    else
      die "${data_dir}/${1} does not appear to be a valid image set directory."
    fi
  ;;
esac

################################################################################
