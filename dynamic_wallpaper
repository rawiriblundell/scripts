#!/bin/bash

# TODO: Attempt to auto-detect and prompt user to confirm?
# Get your location code from https://weather.codes/search
location_code=NZXX0049

################################################################################
# Traps and die()
################################################################################
# Catch our own PID to ensure that die() works within subshells
_self_pid="${$}"
export _self_pid

# Print errors to stderr and then exit
die() {  
  if [ -t 0 ]; then
    printf -- '\e[31m\n[!] %s\e[0m\n\n' "${*}" >&2
  else
    printf -- '\n[!] %s\n\n' "${*}" >&2
  fi
  # Send a TERM signal to the top level PID, this is trapped and exit 1 is forced
  kill -s TERM "${_self_pid}"
}

exit_on_SIGINT() { die Program Interrupted; }
exit_on_SIGTERM() { die Program Terminated; }

trap exit_on_SIGINT SIGINT
trap exit_on_SIGTERM SIGTERM

################################################################################
# Init: ensure required vars and directories are in place
################################################################################
XDG_DATA_HOME="${XDG_DATA_HOME:-$HOME/.local/share}"
XDG_STATE_HOME="${XDG_STATE_HOME:-$HOME/.local/state}"

[[ ! -d "${XDG_DATA_HOME}" ]] && die "${XDG_DATA_HOME} not found"
[[ ! -d "${XDG_STATE_HOME}" ]] && die "${XDG_STATE_HOME} not found"

data_dir="${XDG_DATA_HOME}/dynamic_wallpapers"
state_dir="${XDG_STATE_HOME}/dynamic_wallpapers"

mkdir -p "${data_dir}" || die "Could not create ${data_dir}"
mkdir -p "${state_dir}" || die "Could not create ${state_dir}"

################################################################################

get_sunrise_sunset() {
  curl -s "https://weather.com/weather/today/l/${1:?No location code}" | 
    grep SunriseSunset | 
    grep -oE '((1[0-2]|0?[1-9]):([0-5][0-9]) ?([AaPp][Mm]))'
}

seconds_since_midnight() {
  date -d "1970-01-01 UTC ${1:-$(date +%T)}" +%s
}

get_state() {
  if [[ -r "${config_dir}/current_state" ]]; then
    . "${config_dir}/current_state"
  fi
}

set_state() {
  {
    printf -- '%s\n' "state_file_generated=$(date +%s)" \
      "current_wallpaper=${current_wallpaper}" \
      "current_set_name=${set_name}" \
      "current_set_path=${set_path}"
  } > "${config_dir}/current_state"
}

usage() {
  printf -- '%s\n' "Usage: dynamic_wallpapers setname"
  exit "${1:-0}"
}

mapfile -t sunbounds < <(get_sunrise_sunset "${location_code}")
bound_start=$(seconds_since_midnight "${sunbounds[0]}")
bound_end=$(seconds_since_midnight "${sunbounds[1]}")
bound_size=$(( bound_end - bound_start ))
current_secs=$(seconds_since_midnight)

get_state

case "${1}" in
  (-h|--help|help|--usage|usage)
    usage 0
  ;;
  (''|random)
    # Create an array of set directories from within data_dir
    set_list=( $(find "${data_dir}" -maxdepth 1 -type d | grep -xv "${data_dir}") )
    (( "${#set_list[@]}" == 0 )) && die "No image sets found in ${data_dir}"
    # Randomly select a set from the array
    set_name="${set_list[$RANDOM % ${#set_list[@]}]}"
    printf -- '%s\n' "Randomly selected ${data_dir}/${set_name}..."
  ;;
  (*)
    if [[ -d "${data_dir}/${1}" ]]; then
      set_name="${1}"
    else
      die "${data_dir}/${1} does not appear to be a valid image set directory."
    fi
  ;;
esac

# Define the set_path variable
set_path="${data_dir}/${set_name}"

# Load our images into an array
image_set=( "${data_dir}/${set_name}/"* )

# A one-image set is not what this script is about
(( "${#image_set[@]}" <= 1 )) && die "${set_name} set size too small (<=1)"

# Let's resolve our overnight image first
# Start by selecting the last element in the array
overnight_wallpaper="${image_set[${#image_set[@]}-1]}"
if (( current_secs > bound_end )) && (( current_secs < bound_start )); then
  if [[ "${current_wallpaper}" != "${overnight_wallpaper}" ]]; then
    set_wallpaper "${overnight_wallpaper}"
    write_state "${overnight_wallpaper}"
  fi
fi

# If there's only two images in our set,
# we treat the first as daytime, and the second as nighttime
#
# If there's more than one image in the set, we work on the following logic:
# Between sunset and sunrise, we use the last image in the set
# We sequence the rest in reverse order and then in-order
# For example, with an 8 image set:
# Overnight: 8
# Daytime: 7, 6, 5, 4, 3, 2, 1, 2, 3, 4, 5, 6, 7

if (( "${#image_set[@]}" == 2 )); then
  # If it's daytime, then we load up the first image in the set
  if (( current_secs >= bound_start )) && (( current_secs <= bound_end )); then
    if [[ "${current_wallpaper}" != "${image_set[0]}" ]]; then
      set_wallpaper "${image_set[0]}"
      write_state "${image_set[0]}"
    fi
  fi
else
  for (( i="${#image_set[@]}";i>=0;i-- )); do
    (( i == "${#image_set[@]}" )) && continue
    set_sequence+=( "${image_set[i]}" )
  done
  for (( i=1;i<="${#image_set[@]}";i++ )); do
    (( i == "${#image_set[@]}" )) && continue
    set_sequence+=( "${image_set[i]}" )
  done
  duration="$(( bound_size / "${#set_sequence[@]}" ))"
  counter=0
  test_bound="${bound_start}"
  while (( test_bound <= current_secs )); do
    test_bound=$(( test_bound + duration ))
    (( counter++ ))
  done
  set_wallpaper "${image_set[${set_sequence[counter]}]}"
fi


start:finish:filename
0:${bound_start}:01.jpg

start=0
finish="${bound_start}"

printf -- '%s:%s:%s\n' "${start}" "${finish}" "${image_set[${#image_set[@]}-1]}"

start="${finish}"
finish="$(( finish + duration ))"



while IFS=: read -r start finish wallpaper; do
  if (( current_secs >= start )) && (( current_secs <= finish )); then
    if [[ ! -f /"${wallpaper}" ]]; then

    fi
    set_wallpaper "${wallpaper}"
    break
  fi
done < config_file
